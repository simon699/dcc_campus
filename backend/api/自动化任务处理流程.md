# 自动化任务处理流程文档

## 概述

本文档详细说明了自动化任务监控和处理系统的完整流程。系统由两个核心模块组成：
- **AutoTaskMonitor** (`auto_task_monitor.py`)：任务监控和状态管理
- **Task Handlers** (`task_handlers.py`)：具体任务处理逻辑

---

## 一、系统架构

### 1.1 核心组件

```
┌─────────────────────────────────────────────────────────┐
│              AutoTaskMonitor (监控器)                    │
│  - 获取待处理任务列表                                      │
│  - 管理任务处理状态（避免重复处理）                          │
│  - 检查并更新任务状态（task_type）                          │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│           Task Monitor (定时任务调度器)                    │
│  - 每5分钟执行一次监控                                      │
│  - 根据任务类型触发相应的处理任务                            │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│            Task Handlers (具体任务处理器)                  │
│  - sync_call_job_ids: 同步 call_job_id                    │
│  - query_task_execution: 查询任务执行状态                   │
│  - create_leads_follow: 创建跟进记录                       │
└─────────────────────────────────────────────────────────┘
```

### 1.2 任务状态流转

```
task_type = 1  →  task_type = 2  →  task_type = 3  →  task_type = 4
  (待开始)        (外呼开始)        (外呼完成)        (跟进完成)
```

---

## 二、AutoTaskMonitor 模块详解

### 2.1 核心功能

#### 2.1.1 `get_pending_tasks()` - 获取待处理任务列表

**功能**：筛选出需要处理的任务

**筛选条件**：
- `task_type IN (2, 3)`
  - `task_type = 2`：外呼开始（已创建 job_group，正在外呼中）
  - `task_type = 3`：外呼完成跟进中（外呼已完成，但跟进记录可能未完成）
- `job_group_id IS NOT NULL AND job_group_id != ''`
- 不在正在处理的集合中（避免重复处理）

**特殊处理**：
- **task_type=2**：只要有 `job_group_id` 就处理（即使所有记录都已完成）
- **task_type=3**：任务下还有未完成的记录，包括：
  - 缺少 `call_status` 的记录
  - 缺少 `leads_follow_id` 的记录
  - 缺少 `is_interested` 的记录

**返回**：任务列表，包含 `task_id`, `task_name`, `task_type`, `job_group_id`

#### 2.1.2 `mark_task_processing()` / `mark_task_completed()` - 任务状态管理

**功能**：标记任务为处理中或已完成

**机制**：
- 使用内存集合 `_processing_tasks` 记录正在处理的任务ID
- 记录任务开始处理的时间 `_processing_start_time`
- 超时自动清除（默认300秒）

**用途**：避免同一任务被多个进程重复处理

#### 2.1.3 `check_and_update_task_status()` - 检查并更新任务状态

**功能**：根据 `leads_task_list` 中的数据，判断任务是否完成并更新 `task_type`

**判断逻辑1：外呼完成（task_type = 3）**
- 统计条件：所有已外呼的记录（`call_job_id IS NOT NULL`）
- 更新条件：所有已外呼的记录都有 `call_status`
- SQL：`UPDATE call_tasks SET task_type = 3 WHERE id = task_id`

**判断逻辑2：跟进完成（task_type = 4）**
- 统计条件：`call_status IN ('Succeeded', 'Failed')` 的记录
- 更新条件：所有最终状态的记录都已创建跟进记录（`leads_follow_id IS NOT NULL`）
- SQL：`UPDATE call_tasks SET task_type = 4 WHERE id = task_id`

**重要说明**：
- 只统计 `call_status` 为最终状态（'Succeeded' 或 'Failed'）的记录
- 中间状态（如 'Executing'）不参与判断

#### 2.1.4 `diagnose_task()` - 任务诊断

**功能**：诊断任务为什么没有被处理

**返回信息**：
- 任务基本信息
- 是否符合处理条件
- 不符合的原因
- 统计信息（总记录数、已外呼数、有状态数、有跟进记录数等）

---

## 三、Task Handlers 模块详解

### 3.1 `sync_call_job_ids()` - 同步 call_job_id

**触发时机**：`task_type = 2` 时

**功能**：从阿里云 `job_group` 中获取 `call_job_id`，并更新到 `leads_task_list` 表

**处理流程**：

1. **分页获取 jobs 列表**
   - 调用 `query_jobs_with_result` 接口
   - 分页参数：`page_size = 100`
   - 逐页获取所有 jobs

2. **提取数据**
   - 从每个 job 中提取：
     - `job_id`：外呼任务ID
     - `contacts.phone_number`：电话号码（用于匹配）

3. **匹配并更新**
   - 通过 `leads_phone` 匹配 `leads_task_list` 中的记录
   - 更新条件：`WHERE task_id = X AND leads_phone = Y AND (call_job_id IS NULL OR call_job_id = '')`
   - 批量更新 `call_job_id`

**错误处理**：
- API 调用失败：重试（最多3次，延迟60秒）
- 数据库更新失败：记录警告，继续处理

### 3.2 `query_task_execution()` - 查询任务执行状态并更新

**触发时机**：
- `task_type = 2` 时（获取对话数据）
- `task_type = 3` 时（继续获取未完成的记录）

**功能**：查询外呼任务的执行状态，更新 `call_status`、`call_conversation` 等字段

**处理流程**：

1. **筛选需要处理的记录**
   ```sql
   SELECT COUNT(*) as total
   FROM leads_task_list 
   WHERE task_id = %s 
     AND call_job_id IS NOT NULL 
     AND call_job_id != ''
     AND ((call_status IS NULL OR call_status = '') 
          OR (call_conversation IS NULL OR call_conversation = ''))
   ```

2. **分页处理**
   - 每页处理 200 条记录
   - 调用 `_query_task_execution_core` 获取数据
   - 每页最多重试 3 次（延迟5秒）

3. **提取并更新字段**
   - `call_status`：从 `job.Status` 或 `tasks[-1].Status` 获取
   - `call_conversation`：从 `tasks[-1].Conversation` 获取（JSON格式）
   - `planed_time`：从 `tasks[-1].PlanedTime` 获取
   - `updated_time`：当前时间
   - `call_task_id`：从 `tasks[-1].TaskId` 获取
   - `calling_number`：从 `tasks[-1].CallingNumber` 获取

4. **重要：只保存最终状态**
   - 只有 `call_status` 为最终状态（'Succeeded' 或 'Failed'）时才保存
   - 中间状态（如 'Executing'）不保存，继续轮询

5. **处理跟进记录**
   - 检查是否有需要创建跟进记录的记录（`call_status IN ('Succeeded', 'Failed') AND leads_follow_id IS NULL AND is_interested IS NULL`）
   - 批量触发 `create_leads_follow` 任务（每批1000条）
   - 等待一段时间后检查跟进记录创建情况

6. **处理 is_interested**
   - 检查是否有跟进记录但 `is_interested` 为 NULL 的记录
   - 设置为默认值 0（因为无法从跟进记录推断）

7. **标记任务完成**
   - 所有记录都处理完成后，调用 `auto_task_monitor.mark_task_completed(task_id)`

**错误处理**：
- 网络错误：重试（最多3次）
- 业务错误（如 HTTPException、4008）：不重试，直接返回失败
- 页面处理失败：记录失败列表，继续处理其他页

### 3.3 `create_leads_follow()` - 创建跟进记录

**触发时机**：
- `query_task_execution` 完成后，自动触发
- 批量触发（每批1000条）

**功能**：为外呼任务创建跟进记录，调用 AI 分析通话内容

**处理流程**：

1. **前置检查**
   - 检查是否已存在跟进记录（`leads_follow_id IS NOT NULL`）
   - 检查 `is_interested` 是否已设置（不为 NULL）
   - 检查 `call_status` 是否存在

2. **状态检查**
   - **重要**：只有 `call_status` 为最终状态（'Succeeded' 或 'Failed'）时才创建跟进记录
   - 中间状态（如 'Executing'）：跳过，等待状态变为最终状态

3. **判断处理方式**

   **情况A：call_status = 'Failed'**
   - 直接创建跟进记录，不调用 AI
   - `leads_remark = "客户未接电话，未打通；"` 或 `"呼叫失败；"`
   - `is_interested = 0`
   - `next_follow_time = None`

   **情况B：call_status = 'Succeeded' 但 call_conversation 为空**
   - 跳过创建，等待 `call_conversation` 获取到后再创建
   - 返回成功但 `follow_id = None`

   **情况C：call_status = 'Succeeded' 且有 call_conversation**
   - 调用 AI 分析（`ali_bailian_api`）
   - AI 返回：
     - `leads_remark`：跟进备注
     - `is_interested`：意向判断（0=无法判断，1=有意向，2=无意向）
     - `next_follow_time`：下次跟进时间

4. **创建跟进记录**
   ```sql
   INSERT INTO dcc_leads_follow 
   (leads_id, follow_time, leads_remark, frist_follow_time, new_follow_time, next_follow_time)
   VALUES (%s, %s, %s, %s, %s, %s)
   ```

5. **更新 leads_task_list**
   ```sql
   UPDATE leads_task_list 
   SET leads_follow_id = %s, is_interested = %s
   WHERE call_job_id = %s
     AND is_interested IS NULL
   ```
   - **重要**：只更新 `is_interested IS NULL` 的记录，避免覆盖已有值

6. **触发任务状态检查**
   - 创建跟进记录成功后，调用 `auto_task_monitor.check_and_update_task_status(task_id)`
   - 确保及时更新 `task_type`

**错误处理**：
- AI 调用失败：创建基本跟进记录（`is_interested = 0`）
- JSON 解析失败：创建基本跟进记录
- 数据库操作失败：重试（最多3次，延迟60秒）

### 3.4 `create_leads_follow_by_task_and_phone()` - 通过 task_id 和 phone 创建跟进记录

**功能**：当 `call_job_id` 为空时，通过 `task_id` 和 `leads_phone` 查找记录并创建跟进记录

**处理流程**：与 `create_leads_follow()` 类似，但查询条件不同：
```sql
SELECT call_conversation, leads_id, leads_name, leads_phone, leads_follow_id, call_status, call_job_id, is_interested
FROM leads_task_list 
WHERE task_id = %s 
  AND leads_phone = %s
  AND (call_job_id IS NULL OR call_job_id = '')
  AND is_interested IS NULL
```

---

## 四、完整处理流程

### 4.1 任务创建后的处理流程

```
1. 创建任务 (task_type = 1)
   ↓
2. 分配外呼任务到阿里云 (task_type = 2)
   ↓
3. 触发 process_task_after_creation
   ↓
4. 触发 sync_call_job_ids (同步 call_job_id)
   ↓
5. 延迟触发 query_task_execution (获取对话数据)
```

### 4.2 定时监控流程（每5分钟）

```
1. monitor_pending_tasks 执行
   ↓
2. 调用 auto_task_monitor.get_pending_tasks()
   ↓
3. 遍历待处理任务
   ↓
4. 根据 task_type 触发相应处理：
   
   task_type = 2:
   ├─ sync_call_job_ids (同步 call_job_id)
   └─ query_task_execution (获取对话数据)
   
   task_type = 3:
   └─ query_task_execution (继续获取未完成的记录)
      ├─ 更新 call_status、call_conversation
      ├─ 触发 create_leads_follow (创建跟进记录)
      └─ 检查并更新 task_type
```

### 4.3 数据流转图

```
┌─────────────────┐
│  call_tasks     │
│  (task_type=2)  │
└────────┬────────┘
         │
         ↓
┌─────────────────────────────────────┐
│  sync_call_job_ids                  │
│  同步 call_job_id                   │
└────────┬────────────────────────────┘
         │
         ↓
┌─────────────────────────────────────┐
│  leads_task_list                    │
│  call_job_id 已更新                  │
└────────┬────────────────────────────┘
         │
         ↓
┌─────────────────────────────────────┐
│  query_task_execution               │
│  获取 call_status、call_conversation │
└────────┬────────────────────────────┘
         │
         ├──────────────────────────────┐
         │                              │
         ↓                              ↓
┌─────────────────────┐    ┌──────────────────────────┐
│  call_status 更新   │    │  create_leads_follow     │
│  (最终状态)         │    │  创建跟进记录 + AI分析    │
└─────────────────────┘    └──────────┬───────────────┘
                                       │
                                       ↓
                              ┌─────────────────────┐
                              │  dcc_leads_follow   │
                              │  跟进记录已创建      │
                              └──────────┬──────────┘
                                         │
                                         ↓
                              ┌─────────────────────┐
                              │  check_and_update_  │
                              │  task_status        │
                              │  更新 task_type     │
                              └─────────────────────┘
```

---

## 五、关键设计要点

### 5.1 避免重复处理

**机制**：
- 使用 `_processing_tasks` 集合记录正在处理的任务ID
- 任务开始处理时标记，完成时清除
- 超时自动清除（300秒）

**效果**：避免多个进程同时处理同一任务

### 5.2 只处理最终状态

**原则**：
- `call_status` 只有为最终状态（'Succeeded' 或 'Failed'）时才保存到数据库
- 中间状态（如 'Executing'）不保存，继续轮询
- 跟进记录只对最终状态创建

**原因**：
- 中间状态可能变化，避免数据不一致
- 减少不必要的数据库操作

### 5.3 并发安全

**is_interested 字段保护**：
- 所有更新操作都检查 `is_interested IS NULL`
- 只更新 NULL 值，避免覆盖已有值
- 使用数据库条件更新确保原子性

**示例**：
```sql
UPDATE leads_task_list 
SET leads_follow_id = %s, is_interested = %s
WHERE call_job_id = %s
  AND is_interested IS NULL
```

### 5.4 错误处理和重试

**策略**：
- 网络错误：自动重试（最多3次）
- 业务错误：不重试，直接返回失败
- 页面处理失败：记录失败列表，继续处理其他页

**重试延迟**：
- `sync_call_job_ids`：60秒
- `query_task_execution`：30秒（页面重试5秒）
- `create_leads_follow`：60秒

### 5.5 批量处理优化

**策略**：
- 分页处理：每页200条记录（`query_task_execution`）
- 批量触发：每批1000条（跟进记录创建）
- 等待机制：触发后等待一段时间再检查结果

**示例**：
```python
# 分批获取需要创建跟进记录的记录列表（每批1000条）
batch_size = 1000
for offset in range(0, follow_total, batch_size):
    # 批量触发跟进记录创建任务
    for record in follow_records:
        create_leads_follow.delay(call_job_id)
```

---

## 六、状态更新逻辑

### 6.1 task_type 更新规则

**task_type = 2 → 3（外呼完成）**
- 条件：所有已外呼的记录都有 `call_status`
- 触发：`check_and_update_task_status()` 中检查

**task_type = 3 → 4（跟进完成）**
- 条件：所有最终状态的记录都已创建跟进记录
- 触发：`check_and_update_task_status()` 中检查
- 重要：只统计 `call_status IN ('Succeeded', 'Failed')` 的记录

### 6.2 状态检查时机

1. **跟进记录创建后**
   - `create_leads_follow()` 完成后自动触发
   - `create_leads_follow_by_task_and_phone()` 完成后自动触发

2. **任务处理完成后**
   - `query_task_execution()` 完成后检查

---

## 七、常见问题处理

### 7.1 任务一直处于处理中

**原因**：
- 任务处理超时但未清除状态
- 进程异常退出

**解决**：
- 自动超时清除（300秒）
- 手动调用 `diagnose_task()` 诊断

### 7.2 跟进记录未创建

**可能原因**：
- `call_status` 不是最终状态
- `call_status = 'Succeeded'` 但 `call_conversation` 为空
- AI 调用失败

**处理**：
- 等待 `call_status` 变为最终状态
- 等待 `call_conversation` 获取到
- 检查 AI 调用日志

### 7.3 任务状态未更新

**可能原因**：
- 还有未完成的记录（缺少 `call_status` 或 `leads_follow_id`）
- 中间状态的记录未处理

**处理**：
- 调用 `diagnose_task()` 查看详细统计
- 检查是否有中间状态的记录需要继续轮询

---

## 八、监控和调试

### 8.1 日志关键点

- 任务筛选：`get_pending_tasks()` 返回的任务列表
- 任务处理：每个处理步骤的开始和完成
- 状态更新：`task_type` 的更新
- 错误信息：详细的错误堆栈

### 8.2 诊断工具

**`diagnose_task(task_id)`**
- 查看任务是否符合处理条件
- 查看不符合的原因
- 查看统计信息（总记录数、已外呼数等）

**使用示例**：
```python
from api.auto_task_monitor import auto_task_monitor
result = auto_task_monitor.diagnose_task(task_id)
print(result)
```

---

## 九、总结

### 9.1 核心流程

1. **监控器筛选任务** → 2. **触发处理任务** → 3. **同步 call_job_id** → 4. **获取对话数据** → 5. **创建跟进记录** → 6. **更新任务状态**

### 9.2 关键特性

- ✅ 避免重复处理（任务状态管理）
- ✅ 只处理最终状态（数据一致性）
- ✅ 并发安全（条件更新）
- ✅ 错误处理和重试（可靠性）
- ✅ 批量处理优化（性能）

### 9.3 扩展性

- 支持多进程部署（通过任务状态管理避免冲突）
- 支持任务优先级（通过 Celery 队列配置）
- 支持监控和诊断（便于运维）

---

**文档版本**：1.0  
**最后更新**：2024年  
**维护者**：开发团队

